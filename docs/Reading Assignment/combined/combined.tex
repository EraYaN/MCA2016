\subsection{Hybrid predictor}
The first paper that will be discussed is "Combining Branch Predictors" by Scott McFarling \cite{hybrid}. Although the paper dates from 1993 the concept of a hybrid predictor put forth by this paper is still relevant today and it's inclusion in this comparison paper also allows for discussion on some basic categories of branch predictors. Therefore, as is the case in McFarling's paper, before the hybrid predictor is discussed the concept of bimodal, local and global branch prediction will be explained.
\subsubsection{Bimodal branch prediction}
This form of branch prediction is one of the simplest concepts that can be used in order to make somewhat accurate predictions of whether or not a path will be taken in a branch. It uses the recent history of choices made in branches and assumes that the path the branch will take is probably unchanged. Only when it sees it's prediction fail multiple times will it change it's prediction. One could say there is some inertia in it's predictions. To implement bimodal branch prediction one only needs a register of multiple 2 bit counters which we will call the branch history table (BHT). This register can be addressed using the program counter. Each counter in the register corresponds to a different branch in the code. If the path in the prediction is taken the corresponding counter in the BHT is incremented, if the path is not taken the counter is decremented. It is a saturating counter and therefore it will not overflow if an increment or decrement past it's limits is attempted. The prediction made for that particular branch is then based on the most significant bit in the counter. This is what introduces the inertia in the predictions as after a large amount of correct predictions the prediction will only change if there were two bad predictions in a row. The size of the BHT is very important because for small tables multiple program counters of different branches may map to the same address in the BHT causing interference between the histories of those branches and decreasing the accuracy of the branch predictor.
\subsubsection{Local branch prediction}
With this form of branch prediction the concept of pattern repetition is introduced. One can definitely imagine scenarios (for example small program loops) where instead of long repetitions of the same taken or not taken choice, small patterns appear where for example patterns like 1110 with 1 representing taken and 0 representing not taken will repeat a large number of times. With that example pattern, knowing the history of the last three choices will allow for perfect prediction of the next choice. Local branch prediction makes use of this as a second table is introduced which we will call the pattern table (PT). This table is addressed with the program counter and stores the last few choices of every branch. That pattern (for example 1110) is then used to address the BHT that has the counters. This way, every pattern has it's own counter and therefore it's own prediction. Of course, just like with bimodal prediction, the size of the tables is very important. Not only to avoid multiple branches mapping to the same address, but also because the same small pattern in different branches may require a different prediction. A longer saved history for every branch can avoid that hazard. Local prediction is more accurate than bimodal when larger registers in a design are not an issue.
\subsubsection{Global branch prediction}
This concept does away with the history for different branches and instead looks at the recent history of the program itself. It saves the choice made whenever a branch is encountered without care for what branch it is and then uses the resulting pattern to address a register of counters. This of course becomes increasingly accurate with a longer saved history for choices. The paper shows that global branch prediction is worse than local for all register sizes, but better than bimodal for larger register sizes. McFarling also discusses in his paper an expansion on this concept that introduces some locality in the prediction to increase the performance. By concatenating (called gselect in the paper) or XORing (called gshare) the branch address and global history and using that to address a register of counters significantly improved performance is achieved for all register sizes.
\subsubsection{Hybrid branch prediction}
The most important conclusion of McFarling's paper and the reason it's included in this comparison paper is his suggestion for a hybrid predictor. The hybrid predictor functions as a sort of meta-predictor. It combines the concepts mentioned above as two predictors in one and then predicts which of the two is most likely to give a correct prediction. In order to accomplish this it needs an extra register of counters addressed by the program counter. Much in the same way the bimodal branch predictor uses it's counter register it increments or decrements the 2 bit counters in the table depending on which of the two predictors was right and uses the most significant bit in the counter to determine which predictor to trust. Of course, the hybrid predictor allows for multiple combinations of different predictors. In the paper however a focus is put on combining a bimodal or local predictor with a gshare predictor. Using either of these combinations results in higher prediction accuracies than achieved by any of the earlier discussed methods. Using the local/gshare combination seems to obtain the highest achievable accuracy with arrays larger than 2KB approaching 98.1\% accuracy.